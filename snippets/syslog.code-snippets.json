{
	"Syslog line information": {
		"prefix": "syslog",
		"body": [
			"$3syslog(LOG_ERR, \"[euan] %s, %s, %s, %s, %d$1\", __DATE__, __TIME__, __FILE__, __FUNCTION__, __LINE__$2);"
		],
		"description": "Log line information to syslog"
	},

	"Kernel print message": {
		"prefix": "printk",
		"body": [
			"printk(KERN_ALERT \"DEBUG_MSG: %s, %s, %d$1\", __FILE__, __FUNCTION__, __LINE__$2);"
		],
		"description": "Log line information to dmesg.  Note using the __DATE__ and __TIME__ marcos requires -Wno-error=date-time in the top level makefile"
	},

	"Custom log line information": {
		"prefix": "log_err",
		"body": [
			"log_err(\"[euan] %s, %s, %s, %s, %d$1\", __DATE__, __TIME__, __FILE__, __FUNCTION__, __LINE__$2);"
		],
		"description": "Log line information to syslog"
	},

	"Python shebang": {
		"prefix": "pysh",
		"body": [
			"#!/usr/bin/env python3"
		],
		"description": "Python3 shebang to be placed at the top of python scripts"
	},

	"Bash shebang": {
		"prefix": "bash",
		"body": [
			"#!/usr/bin/env bash"
		],
		"description": "Bash shebang to be placed at the top of bash scripts"
	},

	"Python main": {
		"prefix": "pymain",
		"body": [
			"if __name__==\"__main__\":"
		],
		"description": "Python main function"
	},

	"Log date stamp": {
		"prefix": "print_datestamp",
		"body": [
			"${CURRENT_YEAR/(.*)\\d\\d/${1}/}${CURRENT_MONTH}${CURRENT_DATE}:"
		],
		"description": "Insert a date stamp in the form YYMMDD:"
	},

	"Backtrace function": {
		"prefix": "bkf",
		"body": [
			"#include <execinfo.h>",
			"#include <stdio.h>",
			"#include <stdlib.h>",
			"#include <syslog.h>",
			"/* Obtain a backtrace and print it to stdout. */",
			"static void print_trace (void) {",
			"    void *array[10];",
			"    int size = backtrace (array, 10);",
			"    char **strings = backtrace_symbols (array, size);",
			"    if (strings != NULL) {",
			"        syslog(LOG_ERR, \"[euan][trace]: Obtained %d stack frames.\", size);",
			"        for (int i = 0; i < size; i++) {",
			"            syslog(LOG_ERR, \"[euan][trace]: frame: %d, function: %s\", i, strings[i]);",
			"        }",
			"    }",
			"    free (strings);",
			"}"
		],
		"description": "Function for creating a backtrace in c"
	},

	"Signal function": {
		"prefix": "sif",
		"body": [
			"#include <execinfo.h>",
			"#include <signal.h>",
			"#include <stdio.h>",
			"#include <stdlib.h>",
			"#include <syslog.h>",
			"/* Obtain a backtrace and print it to stdout. */",
			"static void print_signal_trace (int) {",
			"    void *array[10];",
			"    int size = backtrace (array, 10);",
			"    char **strings = backtrace_symbols (array, size);",
			"    if (strings != NULL) {",
			"        syslog(LOG_ERR, \"[euan][trace]: Obtained %d stack frames.\", size);",
			"        for (int i = 0; i < size; i++) {",
			"            syslog(LOG_ERR, \"[euan][trace]: frame: %d, function: %s\", i, strings[i]);",
			"        }",
			"    }",
			"    free (strings);",
			"}",
			"// Place this in main loop:",
			"//signal(SIGSEGV, print_signal_trace);"
		],
		"description": "Function for creating a backtrace on signal in c"
	},
	"Python arguments parser": {
		"prefix": "pyargs",
		"body": [
			"import argparse",
			"parser = argparse.ArgumentParser(prog='$1', description='$2')",
			"parser.add_argument('$3', type=$4str, help='$5')"
		],
		"descriptions": "Outline for python arguments"
	},
	"Editor config default": {
		"prefix": "editor_config",
		"body": [
			"# EditorConfig is awesome: https://EditorConfig.org",
			"",
			"# top-most EditorConfig file",
			"root = true",
			"",
			"# Unix-style newlines with a newline ending every file",
			"[*]",
			"end_of_line = lf",
			"insert_final_newline = true",
			"trim_trailing_whitespace = true",
			"insert_final_newline = true",
			"",
			"# Matches multiple files with brace expansion notation",
			"# Set default charset",
			"[*.{js,py}]",
			"charset = utf-8",
			"",
			"# 4 space indentation",
			"[*.py]",
			"indent_style = space",
			"indent_size = 4",
			"",
			"# Tab indentation (no size specified)",
			"[Makefile]",
			"indent_style = tab",
			"",
			"# Indentation override for all JS under lib directory",
			"[lib/**.js]",
			"indent_style = space",
			"indent_size = 2",
			"",
			"# Matches the exact files either package.json or .travis.yml",
			"[{package.json,.travis.yml}]",
			"indent_style = space",
			"indent_size = 2"
		],
		"description": "Default settings for the contents of an `.editorconfig` file"
	},
	"Time since start up": {
		"prefix": "uptime",
		"body": [
			"#include <iostream>",
			"#include <sys/sysinfo.h>",
			"",
			"long int get_uptime() {",
			"    struct sysinfo sys_info;",
			"    if(sysinfo(&sys_info) != 0){",
			"        return -1;",
			"    }",
			"    return sys_info.uptime;",
			"}"
		],
		"description": "Function for getting the uptime in seconds"
	},
	"Loop log": {
		"prefix": "loop_log",
		"body": [
			"auto monitor_time = std::chrono::steady_clock::now() + std::chrono::seconds(10);",
			"auto interval = std::chrono::seconds(1);",
			"auto whereami = [&monitor_time, &interval](const char* filename, const char* function_name, int line_number){",
			"    auto now = std::chrono::steady_clock::now();",
			"    if ((now - monitor_time) > interval) {",
			"        log_err(\"whereami: %s, %s, %d\", filename, function_name, line_number);",
			"        monitor_time = now;",
			"    }",
			"};",
			"whereami(__FILE__, __FUNCTION__, __LINE__);"
		],
		"description": "Lambda function for logging current position every 10s"
	},
	"Script in Notepad": {
		"prefix": "script",
		"body": [
			"#SCRIPT$1:",
			"$2",
			"#SCRIPT!"
		],
		"description": "Create a parsable script fragment within a Notepad"
	},
	"Log after a timeout": {
		"prefix": "timeoutLogger",
		"body": [
			"#include <atomic>",
			"#include <chrono>",
			"#include <condition_variable>",
			"#include <mutex>",
			"",
			"class TimeoutLogger",
			"{",
			"public:",
			"    TimeoutLogger(const std::string& message, const std::chrono::seconds& timeout = std::chrono::seconds(1))",
			"        : m_timeout(timeout)",
			"        , m_loggingThread(std::thread([this](){LoggingThread();}))",
			"        , m_message(message)",
			"    {};",
			"    ~TimeoutLogger() {",
			"        m_destructed = true;",
			"        m_cvLog.notify_all();",
			"        if (m_loggingThread.joinable()) {",
			"            m_loggingThread.join();",
			"        }",
			"    }",
			"    void UpdateLogMessage(const std::string& message) {",
			"        std::scoped_lock lock(m_mxMessage);",
			"        m_message = message;",
			"    }",
			"private:",
			"    void LoggingThread() {",
			"        std::unique_lock<std::mutex> lock(m_mxLog);",
			"        std::cv_status interrupted = m_cvLog.wait_for(lock, m_timeout);",
			"",
			"        // Only log if we timeout",
			"        if (interrupted == std::cv_status::timeout && !destructed) {",
			"            std::scoped_lock message_lock(m_mxMessage);",
			"            log_err(m_message.c_str());",
			"        }",
			"    }",
			"",
			"    std::mutex m_mxLog;",
			"    std::condition_variable m_cvLog;",
			"    std::chrono::seconds m_timeout = std::chrono::seconds(1); // This variable must be declared before m_loggingThread",
			"    std::mutex m_mxMessage;",
			"    std::string m_message = \"\";",
			"    std::thread m_loggingThread;",
			"    std::atomic<bool> m_destructed = false; // Required in case the destructor is called before the loggingThread is initiailized",
			"};",
			"",
			"std::string ConvertToMessage(const char* date, const char* time, const char* file, const char* function, int line) {",
			"    std::ostringstream oss;",
			"    oss << \"[euan] \" << date << \", \" << time << \", \" << file << \", \" << function << \", \" << std::to_string(line);",
			"    return oss.str();",
			"} // ConvertToMessage(__DATE__, __TIME__, __FILE__, __FUNCTION__, __LINE__);"
		],
		"description": "Log only after a timeout has exceeded"
	},
	"C++ Define Header Guard": {
		"prefix": "header_guard",
		"body": [
			"#ifndef __$1_H__",
			"#define __$1_H__",
			"$2",
			"#endif // __$1_H__"
		],
		"description": "Header guards for C++ header files"
	}
}
